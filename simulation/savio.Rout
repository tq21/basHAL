
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(devtools)
Loading required package: usethis
> load_all()
i Loading sHAL
Loading required package: Matrix
Loaded glmnet 4.1-6
Loading required package: Rcpp
hal9001 v0.4.3: The Scalable Highly Adaptive Lasso
note: fit_hal defaults have changed. See ?fit_hal for details
-- Attaching packages --------------------------------------- tidyverse 1.3.2 --
v ggplot2 3.4.1     v readr   2.1.4
v tibble  3.1.8     v dplyr   1.1.0
v tidyr   1.3.0     v forcats 1.0.0
-- Conflicts ------------------------------------------ tidyverse_conflicts() --
x tidyr::expand() masks Matrix::expand()
x dplyr::filter() masks stats::filter()
x dplyr::lag()    masks stats::lag()
x tidyr::pack()   masks Matrix::pack()
x tidyr::unpack() masks Matrix::unpack()
> source("sim_data.R")

Attaching package: 'data.table'

The following objects are masked from 'package:dplyr':

    between, first, last

The following object is masked from 'package:purrr':

    transpose

> 
> `%+%` <- function(a, b) paste0(a, b)
> 
> n <- 500
> set.seed(123)
> run_sim <- function(n, n_test = 10000) {
+   # univariate
+   sim_uni_smooth_dt <- sim_uni_smooth(n)
+   sim_uni_smooth_dt_test <- sim_uni_smooth(n_test)
+ 
+   sim_uni_jump_dt <- sim_uni_jump(n)
+   sim_uni_jump_dt_test <- sim_uni_jump(n_test)
+ 
+   sim_uni_sin_dt <- sim_uni_sin(n)
+   sim_uni_sin_dt_test <- sim_uni_sin(n_test)
+ 
+   # trivariate
+   sim_tri_smooth_dt <- sim_tri_smooth(n)
+   sim_tri_smooth_dt_test <- sim_tri_smooth(n_test)
+ 
+   sim_tri_jump_dt <- sim_tri_jump(n)
+   sim_tri_jump_dt_test <- sim_tri_jump(n_test)
+ 
+   sim_tri_sin_dt <- sim_tri_sin(n)
+   sim_tri_sin_dt_test <- sim_tri_sin(n_test)
+ 
+   # five-variate
+   sim_five_smooth_dt <- sim_five_smooth(n)
+   sim_five_smooth_dt_test <- sim_five_smooth(n_test)
+ 
+   sim_five_jump_dt <- sim_five_jump(n)
+   sim_five_jump_dt_test <- sim_five_jump(n_test)
+ 
+   sim_five_sin_dt <- sim_five_sin(n)
+   sim_five_sin_dt_test <- sim_five_sin(n_test)
+ 
+   dt_list <- list(sim_uni_smooth_dt, sim_uni_jump_dt, sim_uni_sin_dt,
+                   sim_tri_smooth_dt, sim_tri_jump_dt, sim_tri_sin_dt,
+                   sim_five_smooth_dt, sim_five_jump_dt, sim_five_smooth_dt)
+ 
+   dt_list_test <- list(sim_uni_smooth_dt_test, sim_uni_jump_dt_test, sim_uni_sin_dt_test,
+                        sim_tri_smooth_dt_test, sim_tri_jump_dt_test, sim_tri_sin_dt_test,
+                        sim_five_smooth_dt_test, sim_five_jump_dt_test, sim_five_smooth_dt_test)
+ 
+   for (i in 1:length(dt_list)) {
+     print(i %+% " out of " %+% length(dt_list))
+     dt <- dt_list[[i]]
+     dt_test <- dt_list_test[[i]]
+     y_col_idx <- ncol(dt)
+     x_col_idx <- setdiff(1:ncol(dt), ncol(dt))
+ 
+     # initialize HAL
+     sHAL_obj <- sHAL$new(X = as.data.frame(dt[, x_col_idx]),
+                          y = dt[, y_col_idx],
+                          len_candidate_basis_set = 200,
+                          len_final_basis_set = 200,
+                          max_rows = 500,
+                          max_degree = length(y_col_idx),
+                          batch_size = 200,
+                          n_batch = 300,
+                          p = 0.5,
+                          seed = 8734,
+                          weight_function = "double weight v3",
+                          family = "gaussian",
+                          n_cores = 40)
+     sHAL_res <- sHAL_obj$run(verbose = TRUE, plot = FALSE)
+     sHAL_lasso <- sHAL_res[[1]]
+     sHAL_basis_set <- sHAL_res[[2]]
+ 
+     # get rmse
+     basis_matrix_test <- make_design_matrix(sHAL_basis_set, as.data.frame(dt_test[, x_col_idx]))
+     sHAL_pred <- predict(sHAL_lasso, newx = basis_matrix_test)
+     sHAL_true <- dt_test[, y_col_idx]
+     print("rmse: " %+% sqrt(mean((sHAL_pred - sHAL_true)^2)))
+ 
+     # get number of non zero coefficients
+     print(sum(coef(sHAL_lasso) != 0))
+ 
+     best_loss_traj <- sHAL_obj$best_loss_traj # loss trajectory
+     best_loss_batch <- sHAL_obj$best_loss_batch # batch number for the best loss
+ 
+     # save lasso fit and basis set
+     save(list = c("sHAL_lasso", "sHAL_basis_set", "best_loss_traj", "best_loss_batch"),
+          file = "simulation_" %+% i %+% "_double_weight_v3.RData")
+   }
+ }
> 
> run_sim(n)
[1] "1 out of 9"
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
